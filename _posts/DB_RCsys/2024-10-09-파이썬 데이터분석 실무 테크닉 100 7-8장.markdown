---
layout: post
title:  "파이썬 데이터분석 실무 테크닉 100 7-8장"
date:   2024-10-08 00:00:01 +0800
categories: jekyll update
---

**#파이썬 데이터분석 실무 테크닉 100**

# 7장 물류 네트워크 최적 설계를 위한 테크닉 10

# 앞선 장의 물류 최적화 문제 풀기

## **운송최적화 문제를 풀어보자**

```python
import numpy as np
import pandas as pd
from itertools import product
from pulp import LpVariable, lpSum, value
from ortoolpy import model_min, addvars, addvals

# 데이터 불러오기
df_tc = pd.read_csv('trans_cost.csv', index_col="공장")
df_demand = pd.read_csv('demand.csv')
df_supply = pd.read_csv('supply.csv')

# 초기 설정 #
np.random.seed(1)
# 창고 수
nw = len(df_tc.index)
# 공장 수
nf = len(df_tc.columns)
# 공장과 목적지의 조합(엣지)
pr = list(product(range(nw), range(nf)))

# 수리 모델 작성 #
# 최소화 문제
m1 = model_min()
# 운송량 변수 생성
v1 = {(i,j):LpVariable('v%d_%d'%(i,j),lowBound=0) for i,j in pr}

# 목적함수
# 운송비용*운송량
m1 += lpSum(df_tc.iloc[i][j]*v1[i,j] for i,j in pr)

# 제약조건
# 최대 공급량 이하
for i in range(nw):
    m1 += lpSum(v1[i,j] for j in range(nf)) <= df_supply.iloc[0][i]
# 최소 수요량 이상
for j in range(nf):
    m1 += lpSum(v1[i,j] for i in range(nw)) >= df_demand.iloc[0][j]
m1.solve()

# 총 운송 비용 및 각 운송량 출력 #
df_tr_sol = df_tc.copy()
total_cost = 0
for k,x in v1.items():
    i,j = k[0],k[1]
    df_tr_sol.iloc[i][j] = value(x)
    total_cost += df_tc.iloc[i][j]*value(x)
    
print(df_tr_sol)
print("총 운송 비용:"+str(total_cost))
```

## **최적운송경로를 네트워크로 확인하자**

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx

# 데이터 불러오기
df_tr = df_tr_sol.copy()
df_pos = pd.read_csv('trans_route_pos.csv')

# 객체 생성
G = nx.Graph()

# 노드 설정
for i in range(len(df_pos.columns)):
    G.add_node(df_pos.columns[i])

# 엣지 설정 & 엣지의 가중치 리스트화
num_pre = 0
edge_weights = []
size = 0.1
for i in range(len(df_pos.columns)):
    for j in range(len(df_pos.columns)):
        if not (i==j):
            # 엣지 추가
            G.add_edge(df_pos.columns[i],df_pos.columns[j])
            # 엣지 가중치 추가
            if num_pre<len(G.edges):
                num_pre = len(G.edges)
                weight = 0
                if (df_pos.columns[i] in df_tr.columns)and(df_pos.columns[j] in df_tr.index):
                    if df_tr[df_pos.columns[i]][df_pos.columns[j]]:
                        weight = df_tr[df_pos.columns[i]][df_pos.columns[j]]*size
                elif(df_pos.columns[j] in df_tr.columns)and(df_pos.columns[i] in df_tr.index):
                    if df_tr[df_pos.columns[j]][df_pos.columns[i]]:
                        weight = df_tr[df_pos.columns[j]][df_pos.columns[i]]*size
                edge_weights.append(weight)
                

# 좌표 설정
pos = {}
for i in range(len(df_pos.columns)):
    node = df_pos.columns[i]
    pos[node] = (df_pos[node][0],df_pos[node][1])
    
# 그리기
nx.draw(G, pos, with_labels=True,font_size=16, node_size = 1000, node_color='k', font_color='w', width=edge_weights)

# 표시
plt.show()
```



→ 네트워크 간의 차이가 명확함 → '거의 완전한 결합'

## **최적운송경로가 제약조건을 만족하는지 확인하자**

```python
import pandas as pd
import numpy as np

# 데이터 불러오기
df_demand = pd.read_csv('demand.csv')
df_supply = pd.read_csv('supply.csv')

# 제약조건 계산함수
# 수요측, 최소 수요량을 만족하면 1
def condition_demand(df_tr,df_demand):
    flag = np.zeros(len(df_demand.columns))
    for i in range(len(df_demand.columns)):
        temp_sum = sum(df_tr[df_demand.columns[i]])
        if (temp_sum>=df_demand.iloc[0][i]):
            flag[i] = 1
    return flag
            
# 공급측, 최대 공급량을 만족하면 1
def condition_supply(df_tr,df_supply):
    flag = np.zeros(len(df_supply.columns))
    for i in range(len(df_supply.columns)):
        temp_sum = sum(df_tr.loc[df_supply.columns[i]])
        if temp_sum<=df_supply.iloc[0][i]:
            flag[i] = 1
    return flag

print("수요 조건 계산 결과:"+str(condition_demand(df_tr_sol,df_demand)))
print("공급 조건 계산 결과:"+str(condition_supply(df_tr_sol,df_supply)))
```

# 생산 최적화 문제 풀기

| no | 파일 이름 | 개요 |  |
| --- | --- | --- | --- |
|  | product_plan_material .csv | 제품 제조에 필요한 원료 비율 | 제품 1, 2를 제조하는 데 필요한 원료 1,2,3의 양 |
| 2 | product_plan_profit.csv  | 제품 이익
 | 판매가격-판매원가 |
| 3 | product_plan_stock.csv | 원료 재고 | 현재 각 원료의 재고 |
| 4 | product_plan.csv | 제품 생산량 | 현재 제품 생산량 |

## **생산계획 데이터를 불러오자**

```python
import pandas as pd

df_material = pd.read_csv('product_plan_material.csv', index_col="제품")
df_profit = pd.read_csv('product_plan_profit.csv', index_col="제품")
df_stock = pd.read_csv('product_plan_stock.csv', index_col="항목")
df_plan = pd.read_csv('product_plan.csv', index_col="제품")
```

## **이익을 계산하는 함수를 만들자**

```python
# 이익 계산 함수
# 총 이익 = 제품별 이익*제품별 생산량
def product_plan(df_profit,df_plan):
    profit = 0
    for i in range(len(df_profit.index)):
        for j in range(len(df_plan.columns)):
            profit += df_profit.iloc[i][j]*df_plan.iloc[i][j]
    return profit

print("총 이익:"+str(product_plan(df_profit,df_plan)))
```

## **생산최적화 문제를 풀어보자**

```python
import pandas as pd
from pulp import LpVariable, lpSum, value
from ortoolpy import model_max, addvars, addvals

# 데이터 불러오기
df = df_material.copy()
inv = df_stock

# 수리 모델 작성 #
# 최대화 문제
m = model_max()
# 생산량 변수 생성
v1 = {(i):LpVariable('v%d'%(i),lowBound=0) for i in range(len(df_profit))}

# 목적함수
# 제품별 이익*제품별 생산량
m += lpSum(df_profit.iloc[i]*v1[i] for i in range(len(df_profit)))

# 제약조건
# 원료 사용량 <= 원료 재고
for i in range(len(df_material.columns)):
    m += lpSum(df_material.iloc[j,i]*v1[j] for j in range(len(df_profit)) ) <= df_stock.iloc[:,i]
m.solve()

# 총 이익 및 제품별 생산량 출력 #
df_plan_sol = df_plan.copy()
for k,x in v1.items():
    df_plan_sol.iloc[k] = value(x)
print(df_plan_sol)
print("총 이익:"+str(value(m.objective)))
```

## **최적생산계획이 제약조건을 만족하는지 확인하자**

```python
# 제약 조건 계산 함수
# 원료 사용량과 원료 재고 비교
# 원료 사용량 <= 원료 재고 이면 1
def condition_stock(df_plan,df_material,df_stock):
    flag = np.zeros(len(df_material.columns))
    for i in range(len(df_material.columns)):  
        temp_sum = 0
        for j in range(len(df_material.index)):  
            temp_sum = temp_sum + df_material.iloc[j][i]*float(df_plan.iloc[j])
        if (temp_sum<=float(df_stock.iloc[0][i])):
            flag[i] = 1
        print(df_material.columns[i]+"  사용량:"+str(temp_sum)+", 재고:"+str(float(df_stock.iloc[0][i])))
    return flag

print("제약 조건 계산 결과:"+str(condition_stock(df_plan_sol,df_material,df_stock)))
```

# 물류 최적화와 생산 최적화 동시에 하기

## **물류네트워크 설계문제를 풀어보자**

***목적함수: 운송비+생산비***

```python
import numpy as np
import pandas as pd

제품 = list('AB')
대리점 = list('PQ')
공장 = list('XY')
레인 = (2,2) # 각 공장에 생산 라인이 두 개씩 존재

# 운송비 #
# 공장에서 대리점으로의 운송비
tbdi = pd.DataFrame(((j,k) for j in 대리점 for k in 공장), columns=['대리점','공장'])
tbdi['운송비'] = [1,2,3,1]

# 수요 #
# 대리점별 각 제품의 수요량
tbde = pd.DataFrame(((j,i) for j in 대리점 for i in 제품), columns=['대리점','제품'])
tbde['수요'] = [10,10,20,20]

# 생산 #
# 공장별 레인별 제품의 생산 개수 상하한 및 생산비
tbfa = pd.DataFrame(((k,l,i,0,np.inf) for k,nl in zip (공장,레인) for l in range(nl) for i in 제품), 
                    columns=['공장','레인','제품','하한','상한'])
tbfa['생산비'] = [1,np.nan,np.nan,1,3,np.nan,5,3] 
tbfa.dropna(inplace=True) # 생산비가 NaN인 행은 없어짐
tbfa.loc[4,'상한']=10
```



```python
from ortoolpy import logistics_network
_, tbdi2, _ = logistics_network(tbde, tbdi, tbfa,dep = "대리점", dem = "수요",fac = "공장",
                                prd = "제품",tcs = "운송비",pcs = "생산비",lwb = "하한",upb = "상한")
```


`from ortoolpy import logistics_network`: 물류 네트워크 최적화 문제를 해결하는 데 사용
`logistics_network(tbde, tbdi, tbfa, dep, dem, fac, prd, tcs, pcs, lwb, upb)`: 대리점의 수요를 충족시키기 위해 공장에서 제품을 생산하고 운송할 때, 생산비와 운송비를 최소화하는 최적의 운송 및 생산 계획을 계산

- 매개변수
    - `tbde`: 대리점의 수요 데이터프레임
    - `tbdi`: 대리점과 공장 간의 운송비 데이터프레임
    - `tbfa`: 공장에서의 생산 조건을 나타내는 데이터프레임 (공장에서 제품을 생산할 때의 비용 및 생산량의 상한/하한 제약)
    - `dep`: 대리점을 나타내는 열의 이름
    - `dem`: 대리점에서 요구하는 제품의 수요를 나타내는 열의 이름
    - `fac`: 공장을 나타내는 열의 이름
    - `prd`: 제품을 나타내는 열의 이름
    - `tcs`: 운송 비용을 나타내는 열의 이름
    - `pcs`: 생산 비용을 나타내는 열의 이름
    - `lwb`: 최소 생산량(하한)을 나타내는 열의 이름
    - `upb`: 최대 생산량(상한)을 나타내는 열의 이름
- 반환값
    - 첫 번째 반환 값: 최적화된 운송 계획의 중간 데이터
    - 두 번째 반환 값 (`tbdi2`): 최적화된 운송 경로와 그에 따른 운송량을 포함하는 데이터프레임
        - 각 대리점과 공장 간의 운송 경로 및 운송량이 기록됩니다.
    - 세 번째 반환 값: 최적화 문제의 다른 중간 결과
- `VarX, Y`: 최적화 모델에서 사용된 변수 이름
- `ValX, Y`: 최적화 계산이 끝난 후 해당 변수의 최적값
    - `ValX`: 최적 운송량
    - `ValY`: 최적 생산량

## **최적 네트워크의 운송비용과 그 내역을 계산하자**

```python
tbdi2 = tbdi2[["공장","대리점","운송비","제품","VarX","ValX"]]

# 총 운송비 = '운송비'*'ValX'
trans_cost = 0
for i in range(len(tbdi2.index)):
    trans_cost += tbdi2["운송비"].iloc[i]*tbdi2["ValX"].iloc[i]
print("총 운송비:"+str(trans_cost))
```

## **최적네트워크의 생산비용과 그 내역을 계산하자**

```python
# 총 생산비 = '생산비''ValY'
product_cost = 0
for i in range(len(tbfa.index)):
    product_cost += tbfa["생산비"].iloc[i]*tbfa["ValY"].iloc[i]
print("총 생산비:"+str(product_cost))
```

# 8장 수치 시뮬레이션으로 소비자의 행동을 예측하는 테크닉 10

| No | 파일 이름 | 개요 |  |
| --- | --- | --- | --- |
| 1 | links .csv  | 재구매 고객 20명의 SNS 연결상태 | 연결되어 있으면 1 |
| 2 | links_members.csv | 재구매 고객 540명의 SNS 연결상태 | 연결되어 있으면 1 |
| 3 | info_members.csv | 재구매 고객 540명의 월별 이용현황 |  |

## **인간관계 네트워크를 가시화해보자**

```python
import pandas as pd

df_links = pd.read_csv("links.csv")
```

```python
import networkx as nx
import matplotlib.pyplot as plt

# 그래프 객체 생성
G = nx.Graph()

# 노드 설정
NUM = len(df_links.index)
for i in range(1,NUM+1):
    node_no = df_links.columns[i].strip("Node") # 이름에서 "Node" 부분 삭제
    G.add_node(str(node_no))

# 엣지 설정
for i in range(NUM):
    for j in range(NUM):
        node_name = "Node" + str(j)
        # 노드 i와 노드 j 사이에 연결이 있을 경우
        if df_links[node_name].iloc[i]==1:
            G.add_edge(str(i),str(j))
        
# 그리기
nx.draw_networkx(G,node_color="k", edge_color="k", font_color="w")
plt.show()
```

`.draw_networkx()`: 다른 것과 연결이 많은 노드를 중심에 오게 자동으로 위치를 결정해서 가시화

- 재현성이 없어서 실행할 때마다 다른 네트워크가 표시될 수도


## **입소문에 의한 정보전파 모습을 가시화해보자**

```python
import numpy as np
```

```python
# 연결 여부를 확률적으로 결정 함수 생성
def determine_link(percent):
    rand_val = np.random.rand()
    # 설정한 확률이 랜덤값 이상이면 연결
    if rand_val<=percent:
        return 1
    else:
        return 0
```

```python
# 퍼콜레이션 시뮬레이션 함수 생성
def simulate_percolation(num, list_active, percent_percolation):
    # 노드 i가 활성화된 상태인 경우
    for i in range(num):
        if list_active[i]==1:
            # i번째 노드와 j번째 노드가 연결되어 있는 경우
            for j in range(num):
                node_name = "Node" + str(j)
                if df_links[node_name].iloc[i]==1:
                    # 확률적으로 결정된 연결 여부가 참인 경우
                    if determine_link(percent_percolation)==1:
                        list_active[j] = 1
    return list_active
```

```python
# 변수 생성
percent_percolation = 0.1 # 한달에 입소문을 일으킬 확률
T_NUM = 36 # 36개월 반복
NUM = len(df_links.index) # 노드 수
list_active = np.zeros(NUM) # 활성화 상태 리스트 초기화
list_active[0] = 1 # 0번째 노드 활성화

# 시간에 따른 활성화 상태 기록
list_timeSeries = []
for t in range(T_NUM):
    list_active = simulate_percolation(NUM, list_active, percent_percolation)
    list_timeSeries.append(list_active.copy())
```

```python
# 액티브 노드 가시화 #
# 활성화된 노드일 경우 빨간색으로, 아니면 검은색
def active_node_coloring(list_active):
    #print(list_timeSeries[t])
    list_color = []
    for i in range(len(list_timeSeries[t])):
        if list_timeSeries[t][i]==1:
            list_color.append("r")
        else:
            list_color.append("k")
    #print(len(list_color))
    return list_color
 
# 0개월이 반복되었을 때 그리기
t = 0
nx.draw_networkx(G,font_color="w",node_color=active_node_coloring(list_timeSeries[t]))
plt.show()

# 11개월이 반복되었을 때 그리기
t = 11
nx.draw_networkx(G,font_color="w",node_color=active_node_coloring(list_timeSeries[t]))
plt.show()

# 35개월이 반복되었을 때 그리기
t = 35
nx.draw_networkx(G,font_color="w",node_color=active_node_coloring(list_timeSeries[t]))
plt.show()
```


## **입소문 수의 시계열 변화를 그래프화해보자**

```python
# 시계열 그래프 그리기
# 시간에 따라 입소문이 난 수
list_timeSeries_num = []
for i in range(len(list_timeSeries)):
    list_timeSeries_num.append(sum(list_timeSeries[i]))

plt.plot(list_timeSeries_num)
plt.show()
```



## **회원수의 시계열변화를 시뮬레이션해보자**

```python
# 시간에 따른 인구 수 시뮬레이션
def simulate_population(num, list_active, percent_percolation, percent_disapparence,df_links):
    # 확산 #
    # 노드 i가 활성화된 상태인 경우
    for i in range(num):
        if list_active[i]==1:
            # i번째 노드와 j번째 노드가 연결되어 있는 경우
            for j in range(num):
                if df_links.iloc[i][j]==1:
                    # 확률적으로 결정된 확산 여부가 참인 경우
                    if determine_link(percent_percolation)==1:
                        list_active[j] = 1
    # 소멸 #
    for i in range(num):
        # 확률적으로 결정된 소멸 여부가 참인 경우
        if determine_link(percent_disapparence)==1:
            list_active[i] = 0
    return list_active
```

```python
# 확산 확률 0.1, 소멸 확률 0.05
percent_percolation = 0.1 # 확산 확률
percent_disapparence = 0.05 # 소멸 확률
T_NUM = 100 # 100개월 반복
NUM = len(df_links.index) # 인구 수
list_active = np.zeros(NUM) # 활성화 상태 리스트 초기화
list_active[0] = 1 # 0번째 노드 활성화

# 시간에 따른 활성화 상태 기록
list_timeSeries = []
for t in range(T_NUM):
    list_active = simulate_population(NUM, list_active, percent_percolation, percent_disapparence,df_links)
    list_timeSeries.append(list_active.copy())
```

```python
# 시계열 그래프 그리기
list_timeSeries_num = []
for i in range(len(list_timeSeries)):
    list_timeSeries_num.append(sum(list_timeSeries[i]))

plt.plot(list_timeSeries_num)
plt.show()
```



```python
# 소멸확률 0.2로 바꾸기
percent_disapparence = 0.2 # 소멸 확률
list_active = np.zeros(NUM) # 활성화 상태 리스트 초기화
list_active[0] = 1 # 0번째 노드 활성화

# 시간에 따른 활성화 상태 기록
list_timeSeries = []
for t in range(T_NUM):
    list_active = simulate_population(NUM, list_active, percent_percolation, percent_disapparence,df_links)
    list_timeSeries.append(list_active.copy())
```

```python
# 시계열 그래프 그리기
list_timeSeries_num = []
for i in range(len(list_timeSeries)):
    list_timeSeries_num.append(sum(list_timeSeries[i]))

plt.plot(list_timeSeries_num)
plt.show()
```



## **파라메터 전체를 「상관관계」를 보면서 파악해보자**

```python
# 노드 확산 확률과 소멸 확률 간 상관관계 계산
print("상관관계 계산시작")
T_NUM = 100 # 100개월 반복
NUM_PhaseDiagram = 20 # 확산 확률과 소멸 확률 각각에 20개 값 부여
phaseDiagram = np.zeros((NUM_PhaseDiagram,NUM_PhaseDiagram)) # 상관관계 배열 초기화
for i_p in range(NUM_PhaseDiagram):
    for i_d in range(ㅁNUM_PhaseDiagram):
        percent_percolation = 0.05*i_p
        percent_disapparence = 0.05*i_d
        list_active = np.zeros(NUM) 
        list_active[0] = 1 # 0번째 노드 활성화
        # 100개월 동안 반복
        for t in range(T_NUM):
            list_active = simulate_population(NUM, list_active, percent_percolation, percent_disapparence,df_links)
        # 최종적으로 활성화된 노드 수
        phaseDiagram[i_p][i_d] = sum(list_active)
print(phaseDiagram)
```

```
상관관계 계산시작
[[ 1.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 16.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 19.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 14.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 18. 11. 10.  0. 11.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 16. 16. 17.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 19. 17. 17.  0. 12.  5.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 17. 17. 13. 13. 12.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 17. 16. 16. 13. 15. 10.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 17. 17. 16. 17. 14. 16.  0.  8.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 17. 15. 14. 12. 17. 10.  8. 11.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 17. 17. 19. 14. 12.  7.  9.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 17. 16. 18. 15. 11. 16.  9.  9.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 18. 14. 17. 15. 14. 12. 10.  6.  2.  7.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 18. 14. 16. 13. 12. 15. 16. 13.  0.  0.  0.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 18. 16. 17. 14. 18. 10.  8.  9. 12. 10.  9.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 18. 17. 18. 14. 16. 12. 11.  9. 11.  9.  6.  0.  0.  0.  0.  0.  0.
0.  0.]
[20. 18. 19. 19. 15. 15. 11. 10.  5. 11.  0.  0.  6.  0.  0.  0.  0.  0.
0.  0.]
[20. 18. 18. 13. 17. 17. 14. 11. 10. 12.  8. 13.  6.  0.  0.  0.  0.  0.
0.  0.]
[20. 19. 19. 18. 15. 10. 11.  9. 11.  9. 12.  7.  7.  2.  0.  0.  0.  0.
0.  0.]]
```

```python
# 시각화
plt.matshow(phaseDiagram) # 차원 배열의 값을 색상으로 표현하는 행렬 다이어그램 생성
plt.colorbar(shrink=0.8)
plt.xlabel('percent_disapparence')
plt.ylabel('percent_percolation')
plt.xticks(np.arange(0.0, 20.0,5), np.arange(0.0, 1.0, 0.25)) # 0부터 20까지 5 간격으로 눈금을 설정하고 0.0부터 1.0까지 0.25 간격으로 눈금 표시
plt.yticks(np.arange(0.0, 20.0,5), np.arange(0.0, 1.0, 0.25))
plt.tick_params(bottom=False,
                left=False,
                right=False,
                top=False)
plt.show()
```



## **실제 데이터를 불러와보자**

```python
import pandas as pd

df_mem_links = pd.read_csv("links_members.csv") # 회원 간 연결 상태 (연결되면 1)
df_mem_info = pd.read_csv("info_members.csv") # 회원별 월별 이용 현황 (이용하면 1)
```

## **링크 수의 분포를 가시화해보자**

```python
NUM = len(df_mem_links.index) # 회원 수
array_linkNum = np.zeros(NUM)
# 회원별 총 연결 수
for i in range(NUM):
    array_linkNum[i] = sum(df_mem_links["Node"+str(i)])
```

```python
# 연결 수의 분포
plt.hist(array_linkNum, bins=10,range=(0,250))
plt.show()
```



→ 정규분포에 가까운 모습

## **시뮬레이션을 위해 실제 데이터로부터 파라메터를 추정하자**

```python
NUM = len(df_mem_info.index) # 회원 수
T_NUM = len(df_mem_info.columns)-1 # 개월 수
# 소멸 확률 추정 #
count_active = 0
count_active_to_inactive = 0
for t in range(1,T_NUM):
    for i in range(NUM):
        if (df_mem_info.iloc[i][t]==1): # 현재 달에 활성화된 상태인 경우
            count_active_to_inactive += 1 # 활성화된 상태의 총 횟수 증가
            if (df_mem_info.iloc[i][t+1]==0): # 다음 달에 비활성화된 경우
                count_active += 1 # 활성화에서 비활성화로 변화한 횟수 증가
# 소멸 확률 = 활성화에서 비활성화로 변화한 횟수/활성화된 상태의 총 횟수
estimated_percent_disapparence = count_active/count_active_to_inactive
```

```python
# 확산 확률 추정 #
count_link = 0 # 현재 활성화된 노드와 연결된 비활성화된 노드의 수 카운트
count_link_to_active = 0 # 연결된 비활성화된 노드가 다음 달에 활성화되는 경우 카운
count_link_temp = 0
# 현재 활성화된 회원 추출
for t in range(T_NUM-1):
    df_link_t = df_mem_info[df_mem_info[str(t)]==1] 
    temp_flag_count = np.zeros(NUM)
    # 현재 활성화된 각 회원에 대해, 그 회원과 연결된 회원들 추출
    for i in range(len(df_link_t.index)):
        df_link_temp = df_mem_links[df_mem_links["Node"+str(df_link_t.index[i])]==1]
        # 연결된 회원 중 현재 비활성화된 회원 -> 확산의 대상
        for j in range(len(df_link_temp.index)):
            if (df_mem_info.iloc[df_link_temp.index[j]][t]==0):
                if (temp_flag_count[df_link_temp.index[j]]==0): # 중복 계산되지 않도록
                    count_link += 1
                # 연결된 회원이 다음달에 활성화된 경우
                if (df_mem_info.iloc[df_link_temp.index[j]][t+1]==1):
                    if (temp_flag_count[df_link_temp.index[j]]==0): # 중복 계산되지 않도록
                        temp_flag_count[df_link_temp.index[j]] = 1 
                        count_link_to_active += 1
 # 확산 확률 = 현재 비활성화, 다음 달에 활성화된 회원 수/활성화된 회원과 연결된 비활성화된 회원 수
 estimated_percent_percolation = count_link_to_active/count_link
```

```python
# 소멸 확률
estimated_percent_disapparence # 0.10147163541419416
```

```python
# 확산 확률
estimated_percent_percolation # 0.025184661323275185
```

## **실제데이터와 시뮬레이션을 비교하자**

```python
# 추정한 소멸 확률과 확산 확률로 시뮬레이션
percent_percolation = 0.025184661323275185
percent_disapparence = 0.10147163541419416
T_NUM = 24 # 24개월 동안 진행
NUM = len(df_mem_links.index) # 회원 수
list_active = np.zeros(NUM) # 회원의 활성화 상태 나타내는 배열 초기화
list_active[0] = 1
list_timeSeries = [] # 시간별 회원별 활성화 상태 기록
# 회원의 활성화 상태
for t in range(T_NUM):
    list_active = simulate_population(NUM, list_active, percent_percolation, percent_disapparence,df_mem_links)
    list_timeSeries.append(list_active.copy())
# 시간대별 활성화된 회원 수
list_timeSeries_num = []
for i in range(len(list_timeSeries)):
    list_timeSeries_num.append(sum(list_timeSeries[i]))
# 실제 데이터에서 시간대별 활성화된 회원 수
T_NUM = len(df_mem_info.columns)-1
list_timeSeries_num_real = []
for t in range(0,T_NUM):
    list_timeSeries_num_real.append(len(df_mem_info[df_mem_info[str(t)]==1].index))
```

```python
plt.plot(list_timeSeries_num, label = 'simulated')
plt.plot(list_timeSeries_num_real, label = 'real')
plt.xlabel('month')
plt.ylabel('population')
plt.legend(loc='lower right')
plt.show()
```


→ 프로그램 난수의 영향으로 증가하는 시점이 실제와 다를 수 있음

→ 예측 정확도를 높이기 위해서는 시뮬레이션을 여러 번 실행하여 평균값 계

## **시뮬레이션으로 미래를 예측해보자**

```python
# 36개월까지의 회원 수 예측하기
percent_percolation = 0.025184661323275185
percent_disapparence = 0.10147163541419416
T_NUM = 36
NUM = len(df_mem_links.index)
list_active = np.zeros(NUM)
list_active[0] = 1
list_timeSeries = []
for t in range(T_NUM):
    list_active = simulate_population(NUM, list_active, percent_percolation, percent_disapparence,df_mem_links)
    list_timeSeries.append(list_active.copy())
    
list_timeSeries_num = []
for i in range(len(list_timeSeries)):
    list_timeSeries_num.append(sum(list_timeSeries[i]))
```

```python
plt.plot(list_timeSeries_num, label = 'simulated')
plt.xlabel('month')
plt.ylabel('population')
plt.legend(loc='lower right')
plt.show()
```