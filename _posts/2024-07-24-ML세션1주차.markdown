---
layout: post
title:  "ML세션 1주차"
date:   2024-07-19 20:47:24 +0900
categories: jekyll update
---

**데이터 분석가가 반드시 알아야할 모든 것 2부 10장**

# 10.1 탐색적 데이터 분석(EDA)

- Exploratory Data Analysis
- 극단적인 해석은 피하고 지나친 추론이나 자의적 해석 지양해야 함

## EDA의 목적
- 데이터의 형태와 척도가 분석에 알맞게 되어있는지
- 데이터의 평균, 분산 분포, 패턴  등의 확인 → 데이터 특성 파악
- 데이터의 결축값이나 이상치 파악 및 보완
- 변수 간의 관계성 파악
- 분석 목적과 방향성 점검 및 보정

## 엑셀을 활용한 EDA
- 임의로 데이터 추출해서 직접 눈으로 관찰

## 탐색적 데이터 분석 실습
```python
# 필요한 패키지 설치
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
sns.set(color_codes=True)
%matplotlib inline
```

`import seaborn as sns` <br>
seaborn : 데이터 시각화 라이브러리 <br>
as sns : seaborn의 별칭

`import matplotlib.pyplot as plt` <br>
matplotlib : 다양한 종류의 그래프와 플롯을 만들 수 있게 해주는 라이브러리 <br>
pyplot : Matplotlib의 주요 인터페이스, 간단하고 직관적인 방법으로 그래프를 그릴 수 있는 모듈

`import pandas as pd` <br>
pandas : 데이터 조작과 분석을 위해 설계된 라이브러리, 데이터 프레임 구조를 사용

`sns.set(color_codes=True)` <br>
sns.set : Seaborn의 기본 스타일을 설정 <br>
color_codes=True : Seaborn에서 제공하는 기본 색상 팔레트가 Matplotlib의 색상 코드와 일치하도록

`%matplotlib inline` <br>
: Jupyter Notebook에서 Matplotlib 라이브러리를 사용할 때 그래프를 인라인(inline)으로 표시하기 위해 사용되는 매직 명령어 <br>
-Jupyter Notebook의 셀 안에 그래프를 직접 삽입하여, 그래프를 별도의 창이 아닌 셀 안에서 바로 볼 수 있게

<br>

```python
# 데이터 불러오기
# https://www.kaggle.com/datasets/jessemostipak/hotel-booking-demand
df = pd.read_csv("datasets/hotel_bookings.csv")

# 데이터 샘플 확인
df.head()
```

`df = pd.read_csv("datasets/hotel_bookings.csv")` <br>
: Pandas 라이브러리를 사용하여 CSV 파일(hotel_bookings.csv)을 데이터 프레임(df)으로 불러오는 명령어

`df.head()` <br>
: 기본적으로 첫 데이터 프레임의 첫 5행을 반환하는 명령어 <br>
-원하는 행 수를 인수로 지정할 수도 있음

<br>

```python
df2 = df[['hotel', 'lead_time']]
df2.head()
```

`df2 = df[['hotel', 'lead_time']]` <br>
: 원본 데이터 프레임 ‘df’에서 'hotel'과 'lead_time' 두 개의 열만 선택하여 새로운 데이터 프레임 ‘df2’를 생성하는 명령어

<br>

```python
# 각 컬럼의 속성 및 결측치 확인
df.info()
```

`df.info()` <br>
: 데이터 프레임의 행 수, 각 열의 데이터 타입, 누락된 값의 개수 등 포함, 데이터 프레임의 구조와 데이터 타입 파악하는 명령어

<br>

```python
# 각 컬럼의 통계치 확인
df.describe()
```

`df.describe()` <br>
: 각 칼럼의 통계치를 파악하는 명령어 <br>
-count: 유효한 값의 개수, mean: 평균값, std: 표준 편차, min: 최솟값, 25%: 1사분위수 (하위 25%), 50%: 중앙값 (하위 50%, 2사분위수), 75%: 3사분위수 (하위 75%), max:최댓값

<br>

```python
# 각 컬럼의 왜도 확인
numeric_df = df.select_dtypes(include=['number'])
skewness = numeric_df.skew()
print(skewness)
```

`df.select_dtypes(include=['number'])` <br>
: df에서 숫자 데이터 타입을 가진 열만 선택

`numeric_df.skew()` <br>
: numeric_df의 각 열의 왜도를 계산하는 명령어 <br>
-왜도: 0에 가까울수록 대칭적인 분포, 양의 값은 오른쪽 꼬리가 긴 분포, 음의 값은 왼쪽 꼬리가 긴 분포

<br>

```python
# 각 컬럼의 첨도 확인
numeric_df = df.select_dtypes(include=['number'])
print(numeric_df.kurtosis())
```

`df.kurtosis()` <br>
: numeric_df의 각 열의 첨도를 계산하는 명령어, 양의 값으로 큰 수면 뾰족한 분포, 음의 값으로 작은 수면 평평한 분포
![image.png](https://github.com/user-attachments/assets/4fe22d52-ccc3-4bbd-84c0-ca862d314372)
<br>

```python
# 특정 변수 분포 시각화
plt.rcParams['figure.dpi'] = 300
sns.distplot(df['lead_time'])
```

`plt.rcParams['figure.dpi'] = 300` <br>
: Matplotlib의 설정을 변경하여 생성되는 모든 그래프의 해상도 설정 <br>
-dpi(dots per inch): 그래프의 해상도 결정 <br>
-해상도를 300으로 설정 → 그래프가 더 높은 해상도로 렌더링되어 더 선명하게 보임

`sns.distplot(df['lead_time'])` <br>
: Seaborn을 사용하여 ‘lead_time’ 열의 분포 시각화 <br>
-히스토그램과 커널 밀도 추정(KDE)을 함께 표시
![image-1](https://github.com/user-attachments/assets/632e3210-e5c1-4811-ac64-4337f73b0c59)
<br>

```python
# 호텔 구분에 따른 lead_time 분포 차이 시각화
sns.violinplot(x="hotel", y="lead_time", data=df, inner=None, color=".8")
sns.stripplot(x="hotel", y="lead_time", data=df, size=1)
```

`sns.violinplot(x="hotel", y="lead_time", data=df, inner=None, color=".8")` <br>
-sns.violinplot : seaborn의 violinplot <br>
-x="hotel" : 호텔별로 나눔 <br>
-inner=None : violin plot 내부에 추가적인 요소(박스플롯, 개별 데이터 포인트 등)이 없음 <br>
-color=".8" : 회색, 0(흰색), 1(검은색) 

<br>

`sns.stripplot(x="hotel", y="lead_time", data=df, size=1)`
-sns.stripplot : seaborn의 stripplot <br>
-size=1 : 데이터 포인트의 크기가 1 <br>
![image-2](https://github.com/user-attachments/assets/54d180d5-0a68-42de-b77b-43aa31294ff2)
<br>

# 10.2 공분산과 상관성 분석

데이터 탐색 과정에서 각 변수들의 특성 파악(평균, 왜도, 첨도, 결측치 등) <br>
→ 변수 간의 관계 파악 (입력변수 X와 타깃변수 Y의 관계, 입력 변수 X 간의 관계)

### 상관관계 파악하는 방법
1. 공분산
2. 상관계수 (가정: 데이터가 등간 or 비율 척도, 두 변수가 선형적 관계임)

## 공분산
- 분산(variance) <br>
$Var(X) = E(X-E(X)^2) = E(X^2)-{E(X)}^2$ <br>
variance 클수록 분포가 퍼져있음
- 공분산(covariance) <br>
    $Cov(X,Y)=E((X-E(X))(Y-E(Y)))=E(XY)-E(X)E(Y)$ <br>
    ![image-3](https://github.com/user-attachments/assets/648a2977-390e-4924-aaba-45f45819ba47)    - 양의 상관관계: X_1이 커지면 X_2도 커짐
    - 음의 상관관계: X_1이 작아지면 X_2도 작아짐
    - 무 상관관계: X_1과 X_2는 선형적인 관계가 없음
    - (-)1: X_1과 X_2는 완벽한 직선의 관계

## (피어슨) 상관계수
: 공분산의 한계점인 양(음)수로 (반)비례 관계는 알 수 있지만 값이 커질수록 상관성이 높은지는 판단할 수 없는 것 해결 ← 각 변수 간의 다른 척도기준이 그대로 반영되기 때문 
![image-4](https://github.com/user-attachments/assets/214d1444-4596-4749-8f01-b5171b07ae36)
![image-5](https://github.com/user-attachments/assets/662bf0c3-2cbe-4951-951e-b03ba69d13dc)
![image-6](https://github.com/user-attachments/assets/933216d4-5a8b-4d31-a1fb-844217c8a6d8)
- 산점도의 기울기와 상관계수는 관련x
- 분산의 관계성이 같음 → 기울기와 무관하게 상관계수는 같음
- 상관계수가 높음 → X_2를 예상할 수 있는 정확도(설명력)이 높음
- 상관분석은 두 변수의 선형관계만을 측정하므로
    2차 방정식 그래프와 같은 모양일 경우 상관계수가 낮게 측정됨
    → 두 변수 간 연관성이 존재해도 상관계수는 낮게 나올 수도
    → 상관분석과 더불어 산점도 그래프를 확인해보아야 함
    ![image-7](https://github.com/user-attachments/assets/1d7bd6a2-751c-4f8a-b0a5-8c3bdde51df2)    
    <br>

## 공분산과 상관성 실습

```python
# 필요한 패키지 설치
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
plt.rcParams['figure.dpi'] = 300
```
`import numpy as np` <br>
: 수치 연산을 수행하는 데 사용되는 라이브러리

<br>

```python
# 데이터 불러오기
# https://www.kaggle.com/datasets/deepakkumar1987/correlation
df = pd.read_csv("datasets/wine-quality.csv")

# 데이터 샘플 확인
df.head()
```

```python
# 산점도 행렬 시각화
sns.set(font_scale=1.1) ## 폰트 크기 설정
sns.set_style('ticks') ## 축 눈금 설정
sns.pairplot(df,
             diag_kind='kde' # 상관계수가 1이면 분포로 표시
            )
plt.show()
```
![image-8](https://github.com/user-attachments/assets/bd552527-5008-43ae-830e-1804a1ea76f3)
`sns.set(font_scale=1.1)` <br>
: Seaborn 플롯의 폰트 크기를 1.1배로 조정

`sns.set_style('ticks')` <br>
: Seaborn 플롯의 스타일을 'ticks'로 설정 <br>
-ticks: 플롯의 축에 작은 눈금을 추가하여 플롯의 시각적 세부 사항을 강화

`sns.pairplot()` <br>
: 주어진 df의 모든 숫자 열 쌍에 대해 산점도와 히스토그램 또는 커널 밀도 추정(KDE) 플롯을 생성하는 함수

`diag_kind='kde'` <br>
: 동일한 변수의 산점도를 분포로 표현 ← 동일한 변수는 일직선으로만 나오기 때문에 큰 의미가 없으므로 분포도로 변환

<br>

```python
# 공분산 확인
numeric_df = df.select_dtypes(include=['number'])

# 공분산 행렬 출력
print(numeric_df.cov())
```
```python
# 상관계수 행렬 출력
print(numeric_df.corr())
```
`df.corr(method='pearson')` <br>
: 기본값이 피어슨이기 때문에 생략해도 됨

<br>

```python
# 히트맵 시각화
plt.figure(figsize=(12, 10))
sns.heatmap(numeric_df.corr(), cmap='viridis', annot=True, linewidths=0.5)
plt.title('Correlation Matrix')
plt.show()
```
`plt.figure(figsize=(12, 10))` <br>
: 그래프의 크기를 설정하는 명령어 <br>
-그래프의 너비를 12인치, 높이를 10인치로 설정

`sns.heatmap(numeric_df.corr(), cmap='viridis', annot=True, linewidths=0.5)` <br>
-sns.heatmap(numeric_df.corr()): 상관계수 매트릭스의 히트맵으로 시각화하는 명령어 <br>
-cmap = ‘viridis’ : 색상 팔레트 설정 → 노란색에 가까울수록 양의 상관관계, 보라색에 가까울수록 음의 상관관계 <br>
-annot=True는 각 셀에 상관계수 값을 표시 <br>
-linewidths=0.5는 셀 간의 경계선을 설정

<br>

```python
# clustermap 히트맵 시각화
sns.clustermap(numeric_df.corr(), annot = True, cmap = 'RdYlBu_r', vmin = -1, vmax = 1)
```
`sns.clustermap(numeric_df.corr(), annot = True, cmap = 'RdYlBu_r', vmin = -1, vmax = 1)` <br>
-sns.clustermap(numeric_df.corr()) : 상관 행렬의 계층적 클러스터링을 수행하고, 이를 히트맵으로 시각화하는 명령 <br>
-vmin=-1, vmax=1 : 색상 막대의 범위를 설정
![image-9](https://github.com/user-attachments/assets/c550a47f-a5b0-42f6-b293-46562eac4723)
<br>

```python
# 중복 제거 히트맵 시각화

# 매트릭스의 우측 상단을 모두 True인 1로, 하단을 False인 0으로 변환.
np.triu(np.ones_like(numeric_df.corr()))

# True/False mask 배열로 변환.
mask = np.triu(np.ones_like(numeric_df.corr(), dtype=np.bool))

#  히트맵 그래프 생성
fig, ax = plt.subplots(figsize=(15, 10))
sns.heatmap(df.corr(), 
            mask=mask, 
            vmin=-1, 
            vmax = 1, 
            annot=True, 
            cmap="RdYlBu_r", 
            cbar = True)
ax.set_title('Wine Quality Correlation', pad = 15)
```
![image-10](https://github.com/user-attachments/assets/d8082aea-b0bb-4b30-95a7-c6f628f8a54b)

# 10.3 시간 시각화

## 연속형 시간 시각화

- 시간 간격의 밀도가 높을 때
- 선그래프
- 데이터의 양이 너무 많거나 변동이 심하여 트렌드를 확인하는 것이 어려울 경우,
→ 추세선 삽입 
by 이동 평균 방법: 데이터의 연속적 그룹의 평균 구하기

## 분절형 시간 시각화

- 시간의 밀도가 낮을 때, 값들의 상대적 차이를 나타내는 것에 유리
- 막대그래프
- 누적 막대그래프
: 한 시점에 2개 이상의 세부 항목이 존재할 때 사용
- 점 그래프

## 시간 시각화 실습

```python
# 필요한 패키지 설치
import matplotlib.pyplot as plt
import pandas as pd
import datetime
plt.rcParams['figure.dpi'] = 300
```

```python
# 데이터 불러오기
# https://www.kaggle.com/datasets/rohitsahoo/sales-forecasting
df = pd.read_csv("datasets/superstore.csv")

# 데이터 샘플 확인
df.head()
```

```python
# date 컬럼 날짜형식 변환
df['Date2']= pd.to_datetime(df['Order Date'], infer_datetime_format=True) 
# 날짜 오름차순 정렬
df = df.sort_values(by='Date2')
# 연도 컬럼 생성
df['Year'] = df['Date2'].dt.year

## 선 그래프 용 데이터셋 생성
# 2018년 데이터만 필터링
df_line=df[df.Year == 2018]

# 2018년 일 별 매출액 가공
df_line = df_line.groupby('Date2')['Sales'].sum().reset_index()

df_line.head()
```

`df['Date2']= pd.to_datetime(df['Order Date'], infer_datetime_format=True)` <br>
-pd.to_datetime : ‘Order Date’ 칼럼의 자료형이 원래 string인데 datetime 자료형으로 바꿔주고 칼럼 이름을 ‘Date2’라고 함 <br>
-infer_datetime_format=True : 자동으로 년/월/일 추정하여 바꿔줌 <br>
-format=’%d/%m/%y’ : 일/월/년으로 지정 <br>
-df['Date2'] = pd.to_datetime(df['Order Date'], dayfirst=True, errors='coerce') : colab에서는 위의 코드 에러 뜸 → dayfirst=True로 제일 앞이 일로 지정

`df = df.sort_values(by='Date2')` <br>
: 날짜 오름차순 정렬

`df['Year'] = df['Date2'].dt.year` <br>
: ‘Date2’의 year를 ‘Year’칼럼으로 생성

`df_line=df[df.Year == 2018]` <br>
: 2018년의 데이터만 필터링

`df_line = df_line.groupby('Date2')['Sales'].sum().reset_index()` <br>
-df_line.groupby(’Date2’) : 같은 ‘Date2’끼리 묶음 <br>
-[’Sales’].sum() : ‘Sales’를 sum함 <br>
-reset_index() : df_line = df_line.groupby('Date2')['Sales'].sum()을 하면 인덱스가 자동으로 새로 생성되는데 원래의 인덱스로 다시 바꿔줌

<br>

```python
# 30일 이동평균 생성
df_line['Month'] = df_line['Sales'].rolling(window=30).mean()

# 선 그래프 시각화
ax = df_line.plot(x='Date2', y='Sales',linewidth = "0.5")
df_line.plot(x='Date2', y='Month', color='#FF7F50', linewidth = "1", ax=ax)
```
​
`df_line['Month'] = df_line['Sales'].rolling(window=30).mean()` <br>
: 30개의 ‘Sales’데이터의 평균을 삽입하기 위해 새로운 칼럼 ‘Month’ 생성 → 추세선

`ax = df_line.plot(x='Date2', y='Sales',linewidth = "0.5")` <br>
: ax는 객체

`df_line.plot(x='Date2', y='Month', color='#FF7F50', linewidth = "1", ax=ax)` <br>
: 좌변의 ax는 plot 메서드 안에 있는 파라미터, 우변의 ax는 위에서 설정해 놓은 것
![image-11](https://github.com/user-attachments/assets/5e754a02-d0bc-4397-ba6f-9d44ae686608)

<br>

```python
# 연도 별 판매량 데이터 가공
df_bar_1 = df.groupby('Year')['Sales'].sum().reset_index()

df_bar_1.head()
```

`df_bar_1 = df.groupby('Year')['Sales'].sum().reset_index()` <br>
: ‘Year’로 groupby 하고 ‘Sales’를 sum함

<br>

```python
# 연도별 매출액 막대 그래프 시각화
ax = df_bar_1.plot.bar(x='Year', y='Sales', rot=90, figsize=(10,5))
```

`ax = df_bar_1.plot.bar(x='Year', y='Sales', rot=90, figsize=(10,5))` <br>
-df_bar_1.plot.bar :  막대그래프 <br>
-rot=90 : x축의 라벨을 90도 회전 <br>
-figsize=(10, 5) : 너비 10인치, 높이 5인 그래프
![image-12](https://github.com/user-attachments/assets/79cf4b6b-9e1b-441c-bec5-1997a6804be7)

<br>

```python
#연도별, 고객 세그먼트 별 매출액 데이터 가공
df_bar_2 = df.groupby(['Year', 'Segment'])['Sales'].sum().reset_index()

# 고객 세그먼트를 컬럼으로 피벗
df_bar_2_pv = df_bar_2.pivot(index='Year', columns='Segment', values='Sales').reset_index()
df_bar_2_pv.head()
```

`df_bar_2 = df.groupby(['Year', 'Segment'])['Sales'].sum().reset_index()` <br>
: 'Year', 'Segment'으로 groupby한 후 ‘Sales’ sum

`df_bar_2_pv = df_bar_2.pivot(index='Year', columns='Segment', values='Sales').reset_index()` <br>
-df_bar_2.pivot : df 재구조화 <br>
-index='Year', columns='Segment', values='Sales’ : 행이 ‘Year’, 열이 ‘Segment’, 값이 ‘Sales’

<br>

```python
# 연도 별 고객 세그먼트 별 매출액 누적 막대 그래프 시각화
df_bar_2_pv.plot.bar(x='Year', stacked=True, figsize=(10,7))
```

`df_bar_2_pv.plot.bar(x='Year', stacked=True, figsize=(10,7))` <br>
-df_bar_2_pv.plot.bar(stacked=True) → 누적 막대 그래프 <br>
-df_bar_2_pv.plot.bar(stacked=False) → 각 연도별로 그래프가 ‘Segment’의 개수만큼 나옴
![image-13](https://github.com/user-attachments/assets/6414c9df-ea9a-4b9f-8de2-756743b656fa)

# 10.4 비교 시각화

## 히트맵 차트

- 그룹과 비교 요소가 많을 때
- 차트의 행은 그룹, 열은 요소

1. 하나의 변수(그룹) x N개의 각 변수에 해당하는 값들(수치형)
![image-14](https://github.com/user-attachments/assets/fdfb20ed-4416-4f6d-992e-d9f78a82048a)

2. 하나의 변수(그룹) x 하나의 변수(그룹/수준) x N개의 각 변수에 해당하는 값들(수치형)
![image-15](https://github.com/user-attachments/assets/eddb4243-d8b5-45cc-b5be-4be4cdd599fa)

## 방사형 차트

- 게임에서 캐릭터가 하나의 그룹, 각 능력이 변수

1. 하나의 차트에 하나의 그룹을 시각화
![image-16](https://github.com/user-attachments/assets/077f4cfe-78c9-4d77-b6ce-2d4ae2ab1868)

2. 하나의 차트에 모든 그룹을 한 번에 시각화
![image-17](https://github.com/user-attachments/assets/7bc025de-5b31-4186-a6d6-4cf3f1ff60ba)

## 평행 좌표 그래프

- 그룹별 요소 비교 시각화

1. 전략 캔버스
![image-18](https://github.com/user-attachments/assets/79a6afb7-6b60-4b06-82d5-4125f14d4491)

2. 평행 좌표 그래프
    - 효과적으로 표현하려면 변수별 값을 정규화
    ← 가장 낮은 값 0%, 가장 높은 값 100%
![image-19](https://github.com/user-attachments/assets/f5a79ea4-3817-41c0-9f8c-626ee3b65060)

## 비교 시각화 실습

```python
# 필요한 패키지 설치
import matplotlib.pyplot as plt
import pandas as pd
import datetime
import seaborn as sns
import numpy as np
from math import pi
from pandas.plotting import parallel_coordinates
plt.rcParams['figure.dpi'] = 300
```

```python
# 데이터 불러오기
# https://www.kaggle.com/datasets/umutalpaydn/nba-20202021-season-player-stats
df = pd.read_csv("nba2021_advanced.csv")

# 데이터 샘플 확인
df.head()
```

```python
# 히트맵 시각화 V1을 위한 데이터 전처리

# 5개 팀만 필터링
df1 = df[df['Tm'].isin(['ATL','BOS','BRK','CHI','CHO'])]

# 6개 컬럼만 필터링 
df1 = df1[['Tm', 'ORB%','TRB%','AST%','BLK%','USG%']]

#  팀 별 요소 평균 전처리
df1 = df1.groupby('Tm').mean()
df1.head()
```

`df1 = df[df['Tm'].isin(['ATL','BOS','BRK','CHI','CHO'])]` <br>
: ‘Tm’ 칼럼이 'ATL','BOS','BRK','CHI','CHO' 에 존재하는 행들을 ‘df1’이라는 새로운 df로 지정

`df1 = df1[['Tm', 'ORB%','TRB%','AST%','BLK%','USG%']]` <br>
: df1에서 칼럼 'Tm', 'ORB%','TRB%','AST%','BLK%','USG%’만 포함하는 새로운 df를 df1으로 저장

<br>

```python
# 히트맵 시각화 V1

fig = plt.figure(figsize=(8,8))
fig.set_facecolor('white')
plt.pcolor(df1.values)

# x축 컬럼 설정
plt.xticks(range(len(df1.columns)),df1.columns) 
# y축 컬럼 설정
plt.yticks(range(len(df1.index)), df1.index)
# x축 레이블 설정
plt.xlabel('Value', fontsize=14)
# y축 레이블 설정
plt.ylabel('Team', fontsize=14) 
plt.colorbar()
plt.show()
```

`fig.set_facecolor('white')` <br>
: 배경색을 흰색으로

`plt.pcolor(df1.values)` <br>
: ‘.pcolor’ 함수를 이용하여 2차원 배열을 색으로 표현하며, ‘.values’로 ‘df1’의 값을 넘파이 배열로 반환

`plt.xticks(range(len(df1.columns)), df1.columns)` <br>
: x축에 len(df1.columns) 개수만큼의 tick mark에 df1.column 이름을 붙임

`plt.xlabel('Value', fontsize=14)` <br>
: x축에 ‘Value’를 label로 설정, 글꼴 크기 14

`plt.colorbar()` <br>
: color bar로 어떤 색상이 어떤 값을 나타내는지 시각적으로 보여줌

<br>

```python
# 히트맵 시각화 V2를 위한 데이터 전처리

# 5개 팀만 필터링
df2 = df[df['Tm'].isin(['ATL','BOS','BRK','CHI','CHO'])]

# 팀명, 연령, 참여 게임 수 컬럼만 필터링
df2 = df2[['Tm','Age','G']]

# 팀 - 연령 기준 평균으로 전처리
df2 = df2.groupby(['Tm','Age']).mean().reset_index()

# 테이블 피벗
df2 = df2.pivot(index='Tm', columns='Age', values='G')
df2.head()
```

`.reset_index()` <br>
: df의 기존 인덱스가 열로 이동하며, 새로운 정수 인덱스가 생성 <br>
-사용하는 경우: 기존 인덱스를 열로 변환할 때, df를 결합하거나 정렬할 때 인덱스가 필요 없을 때 <br>
-사용하지 않는 경우: 특정 열이 인덱스로 유지되어야할 때, 현재 인덱스가 데이터를 식별하는 데 중요한 경우 <br>
-groupby를 하면 해당 칼럼들이 인덱스가 됨 <br>
-.reset_index()를 하면 다시 칼럼으로 바뀜 <br>

`df2.pivot(index='Tm', columns='Age', values='G')` <br>
-.povot() : df 재구조화 <br>
-index='Tm', columns='Age', values='G’ : 행이 ‘Tm’, 열이 ‘Age’, 값이 ‘G’
![image-20](https://github.com/user-attachments/assets/f4db0d6d-5960-49b2-9d39-cd288dfd32a5)

<br>

```python
# 히트맵 시각화 V2

fig = plt.figure(figsize=(8,8))
fig.set_facecolor('white')
 
plt.pcolor(df2.values)
# x축 컬럼 설정
plt.xticks(range(len(df2.columns)),df2.columns)
# y축 컬럼 설정
plt.yticks(range(len(df2.index)), df2.index)
# x축 레이블 설정
plt.xlabel('Age', fontsize=14)
# y축 레이블 설정
plt.ylabel('Team', fontsize=14) 
plt.colorbar()
plt.show()
```

```python
# 방사형 차트를 위한 인덱스 초기화
df3 = df1.reset_index()
df3.head()
```

`df3 = df1.reset_index()` <br>
: df1에서 ‘Tm’이 인덱스로 사용 → df3에서 ‘Tm’이 칼럼으로 사용
![image-21](https://github.com/user-attachments/assets/2c0816ee-782b-4314-9237-88ec8a0c9a0a) → df1
![image-22](https://github.com/user-attachments/assets/b197b710-eedc-4421-bd1c-b413520d9c57) → df3
<br>

```python
# 방사형 차트 - 하나씩 시각화

labels = df3.columns[1:]
num_labels = len(labels)

# 등분점 생성 -> 각도 리스트 생성    
angles = [x/float(num_labels)*(2*pi) for x in range(num_labels)] 
angles += angles[:1] # 시작점 생성
    
my_palette = plt.cm.get_cmap("Set2", len(df3.index))
 
fig = plt.figure(figsize=(15,20))
fig.set_facecolor('white')

# 데이터 리스트 생성
for i, row in df3.iterrows():
    color = my_palette(i)
    data = df3.iloc[i].drop('Tm').tolist()
    data += data[:1]
    
    ax = plt.subplot(3,2,i+1, polar=True)
    # 시작점 설정
    ax.set_theta_offset(pi / 2)
    # 시계방향 설정
    ax.set_theta_direction(-1) 
    
    # 각도 축 눈금 생성
    plt.xticks(angles[:-1], labels, fontsize=13)
    # 각 축과 눈금 사이 여백생성
    ax.tick_params(axis='x', which='major', pad=15)
    # 반지름 축 눈금 라벨 각도 0으로 설정
    ax.set_rlabel_position(0)
    # 반지름 축 눈금 설정
    plt.yticks([0,5,10,15,20],['0','5','10','15','20'], fontsize=10) 
    plt.ylim(0,20)
    
    # 방사형 차트 출력
    ax.plot(angles, data, color=color, linewidth=2, linestyle='solid')
    # 도형 안쪽 색상 설정
    ax.fill(angles, data, color=color, alpha=0.4) 
    # 각 차트의 제목 생성
    plt.title(row.Tm, size=20, color=color,x=-0.2, y=1.2, ha='left') 
# 차트 간 간격 설정
plt.tight_layout(pad=3)
plt.show()
```

`angles = [x/float(num_labels)*(2*pi) for x in range(num_labels)]` <br>
: 리스트 컴프리헨션으로 각 라벨에 대한 각도들을 리스트로 생성 <br>
```python
angles = [ ]
for x in range(num_labels):
    angle = x / float(num_labels) * (2 * pi)
    angles.append(angle)
```
보다 훨씬 간단함

`angles += angles[:1]` <br>
: 리스트의 맨 앞 요소를 맨 뒤에 추가함으로써 처음과 끝 연결 <br>
→ 방사형 차트에서 각도가 완전한 원을 형성하도록 보장함

`plt.cm.get_cmap("Set2", len(df3.index))` <br>
-plt.cm.get_cmap : matplotlib의 컬러맵 함수 호출 <br>
-Set2 :  사용할 컬러맵의 이름 <br>
-len(df3.index) : 각 항목에 고유한 색상을 할당하기 위해 컬러맵에서 몇 가지 색상을 생성해야 하는지 결정

`for i, row in df3.iterrows(): color = my_palette(i) data = df3.iloc[i].drop('Tm').tolist() data += data[:1]` <br>
-.iterrows() : df3의 각 행을 (index, series(row의 데이터))의 튜플 형태로 반환 <br>
-.iloc[i] : 행 번호를 기준으로 행을 선택하는 메서드 <br>
-.drop(’Tm’) : ‘Tm’칼럼 제외 <br>
-.tolist() : series를 list로 변환 <br>
-data += data[:1] : 방사형 차트를 완전한 원형으로 만들기 위해 리스트의 맨 앞 값을 맨 뒤에 추가

`plt.subplot(3,2,i+1, polar=True)` <br>
: 하나의 figure에 3행 2열의 subplot 레이아웃 생성 <br>
→ 총 6개의 서브플롯 공간 생성, i+1번째 위치에 방사형(polar) 플롯 추가 <br>
-.subplot() : 하나의 그림(figure) 안에 여러 개의 플롯을 배열할 수 있도록 도와주는 함수

`ax.set_theta_offset(pi / 2)` <br>
: ax의 시작점을 pi/2 즉, 90도로 설정

`ax.set_theta_direction(-1)` <br>
: 각도가 시계 방향으로 증가하도록 변경 <br>
-기본적으로 방사형 플롯의 각도는 시계 반대 방향으로 증가 (0(rad) → pi/2(rad) → pi(rad) → 3pi/2(rad))

`plt.xticks(angles[:-1], labels, fontsize=13)` <br>
: angles 리스트에서 마지막 각도를 제외한 리스트와 labels 리스트 대응시키고 label의 폰트 사이즈는 13으로 설정

`ax.tick_params(axis='x', which='major', pad=15)` <br>
: x축 - labels과 major 눈금의 끝인 ‘20’ 간의 간격이 15

`ax.set_rlabel_position(0)` <br>
: 시작 축과 눈금 라벨 간의 간격이 0

`plt.yticks([0,5,10,15,20],['0','5','10','15','20'], fontsize=10)` <br>
: y축의 눈금 위치와 레이블 설정 <br>
-[0,5,10,15,20]은 y축의 눈금 위치, ['0','5','10','15','20']는 각 눈금 위치에 표시될 레이블 <br>
-레이블 글꼴 크기 10

`plt.ylim(0,20)` <br>
: y축의 최소 0 최대 20

`ax.plot(angles, data, color=color, linewidth=2, linestyle='solid')` <br>
: 방사형 차트에서 데이터를 플롯하는 메서드 (선)

`ax.fill(angles, data, color=color, alpha=0.4)` <br>
: 방사형 차트에서 데이터를 채우는 메서드 (선 내부)

`plt.title(row.Tm, size=20, color=color,x=-0.2, y=1.2, ha='left')` <br>
: 방사형 차트의 제목을 설정하는 메서드 <br>
-row.Tm : ‘Tm’의 row값을 제목으로 <br>
-x=-0.2, y=1.2 : 방사형 차트의 중심을 기준으로 좌우상하 위치 조정 <br>
-ha='left': 제목의 수평 정렬 설정, 여기서는 왼쪽 정렬 <br>

`plt.tight_layout(pad=3)` <br>
-plt.tight_layout() : 모든 서브플롯 사이의 간격을 자동으로 조정하여 겹치지 않도록 <br>
-pad=3 : 서브플롯 간의 패딩 설정

<br>

```python
# 방사형 차트 - 한번에 시각화

labels = df3.columns[1:]
num_labels = len(labels)

# 등분점 생성
angles = [x/float(num_labels)*(2*pi) for x in range(num_labels)]
# 시작점 생성
angles += angles[:1] 
    
my_palette = plt.cm.get_cmap("Set2", len(df3.index))
 
fig = plt.figure(figsize=(8,8))
fig.set_facecolor('white')

ax = fig.add_subplot(polar=True)
for i, row in df3.iterrows():
    color = my_palette(i)
    data = df3.iloc[i].drop('Tm').tolist()
    data += data[:1]
    
    # 시작점
    ax.set_theta_offset(pi / 2) 
    # 시계방향 설정
    ax.set_theta_direction(-1) 
    
    # 각도 축 눈금 생성
    plt.xticks(angles[:-1], labels, fontsize=13)
    # 각 축과 눈금 사이 여백생성
    ax.tick_params(axis='x', which='major', pad=15) 
    # 반지름 축 눈금 라벨 각도 0으로 설정 
    ax.set_rlabel_position(0) 
    # 반지름 축 눈금 설정
    plt.yticks([0,5,10,15,20],['0','5','10','15','20'], fontsize=10) 
    plt.ylim(0,20)
    
    # 방사형 차트 출력
    ax.plot(angles, data, color=color, linewidth=2, linestyle='solid', label=row.Tm) 
    # 도형 안쪽 색상 설정
    ax.fill(angles, data, color=color, alpha=0.4) 
    
plt.legend(loc=(0.9,0.9))
plt.show()
```

`fig.add_subplot(polar=True)` <br>
: 방사형 차트 하나에 여러 그래프 그리기

`plt.legend(loc=(0.9,0.9))` <br>
: 플롯에 범례(legend)를 추가
-loc 매개변수는 범례의 위치를 지정, (0.9, 0.9)는 범례가 플롯의 오른쪽 상단 구석에 배치

<br>

```python
# 팀 기준 평행 좌표 그래프 생성

fig,axes = plt.subplots()
plt.figure(figsize=(16,8)) # 그래프 크기 조정
parallel_coordinates(df3,'Tm',ax=axes, colormap='winter',linewidth = "0.5")
```

### .subplot() vs .subplots()

- 서브플롯 생성 방법:
    - `plt.subplot`은 하나의 서브플롯을 추가할 때 사용
    - `plt.subplots`는 여러 개의 서브플롯을 한 번에 생성하고, 배열로 반환하여 각 서브플롯을 쉽게 관리
- 서브플롯 접근:
    - `plt.subplot`을 사용하면 서브플롯을 개별적으로 생성하고, 각 서브플롯에 직접 접근하기 어려움
    - `plt.subplots`를 사용하면 반환된 axes 배열을 통해 각 서브플롯에 쉽게 접근 가능
- 유연성:
    - `plt.subplots`는 서브플롯을 배열 형태로 관리, 코드의 유연성과 가독성 높음
    - `plt.subplot`은 간단한 경우에 유용하지만, 서브플롯이 많아지면 관리가 어려움
    
<br>

`fig,axes = plt.subplots()` <br>
: Matplotlib에서 하나의 그림(figure)과 하나 이상의 서브플롯(subplots)을 생성하는 함수

`parallel_coordinates(df3,'Tm',ax=axes, colormap='winter',linewidth = "0.5")` <br>
: Pandas의 시각화 도구로, 데이터프레임의 다양한 범주형 데이터에 대한 평행 좌표 플롯을 생성 <br>
-`'Tm'`: 범주형 데이터로 사용될 컬럼 <br>
-`ax=ax`: 서브플롯을 지정

# 10.5 분포 시각화

1. 양적 척도(연속형)
- 막대 그래프
- 선 그래프
- 히스토그램: 겹치지 않는 변수의 구간을 동일하게 나눠서 구간별 도수를 막대그래프로 표현
    - bin : 각 구간
    - density : 구간의 높이, 가로축의 단위 구간에 속한 값의 비율
    - 처음에는 구간을 20개 정도로 세세하게 나눠서 분포를 살펴본 다음 정보의 손실이 커지기 전까지 구간의 개수 줄여감
1. 질적 척도(명목형)

: 전체를 100%로 하여 구성 요소들의 분포 정도를 면적으로 표현, 수치를 차트 위에 함께 표현하는 것이 좋음
- 파이 차트 <br>
![image-23](https://github.com/user-attachments/assets/d3c9ea03-b47b-41f0-8e7b-878152741c79)
- 도넛 차트 <br>
![image-24](https://github.com/user-attachments/assets/2275b550-5f7d-48a8-8f67-7c4cc7082e84)
- 트리맵 차트
    - 구성요소가 복잡할 때 사용
    - 하나의 큰 사각형을 구성요소의 비율에 따라 작은 사각형으로 쪼개어 분포 표현
    - 사각형 안에 더 작은 사각형을 포함시켜서 위계구조 표현
    - 단점: 구성요소들 간의 규모 차이가 크면 표현이 어려움
    ![image-25](https://github.com/user-attachments/assets/ba910a86-0593-4991-b3ab-4704eab224f9)
- 와플 차트
    - 일정한 네모난 조각들로 분포 표현
    - 트리맵차트처럼 위계구조를 표현하지는x
    ![image-26](https://github.com/user-attachments/assets/2356fa73-ab0f-4fcf-82ee-0d4e53ceaa2d)

```python
# 필요한 패키지 설치
!pip install plotly
!pip install pywaffle
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import numpy as np
import plotly.express as px
from pywaffle import Waffle
plt.rcParams['figure.dpi'] = 300
```

`!pip install plotly`
`!pip install pywaffle`
: plotly와 ptwaffle 설치

`import plotly.express as px`
- plotly.express: Plotly 라이브러리의 고수준 인터페이스로, 데이터를 시각화하는데 필요한 많은 기본 설정을 간편하게 처리

`from pywaffle import Waffle`
- PyWaffle : Python에서 와플 차트를 생성하기 위한 라이브러리
- Waffle : Matplotlib의 FigureClass로 사용되어 와플 차트를 생성하는 클래스

<br>

```python
# 데이터 불러오기
# https://www.kaggle.com/datasets/sewonghwang/six-countries-height-samples
df = pd.read_csv("datasets/six_countries_height_samples.csv")

# 데이터 샘플 확인
df.head()
```

```python
# 기본 히스토그램 시각화

#  신장 컬럼만 필터링
df1 = df[['height_cm']]

# 10cm 단위로 히스토그램 시각화
plt.hist(df1, bins=10, label='bins=10')
plt.legend()
plt.show()
```

`plt.hist(df1, bins=10, label='bins=10')`
- plt.hist() : 히스토그램을 생성
- bins=10 : 10cm 단위로 설정
![image-27](https://github.com/user-attachments/assets/36553c37-5cd6-49f7-b904-172fc410a63b)

<br>

# 남성 여성 히스토그램 시각화

```python
#  남성 여성 별도 데이터셋 생성
df1_1 = df[df['sex'].isin(['man'])]
df1_1 = df1_1[['height_cm']]
df1_2 = df[df['sex'].isin(['woman'])]
df1_2 = df1_2[['height_cm']]

# 10cm 단위로 남성, 여성 신장 히스토그램 시각화
plt.hist(df1_1, color = 'green', alpha = 0.2, bins = 10, label = 'MAN', density = True)
plt.hist(df1_2, color = 'red', alpha = 0.2, bins = 10, label = 'WOMAN', density = True)
plt.legend()
plt.show()
​```

`plt.hist(df1_1, color = 'green', alpha = 0.2, bins = 10, label = 'MAN', density = True)`
- alpha = 0.2 : 투명도 설정
- density = True : 히스토그램을 밀도(normalized) 히스토그램으로 생성

![image-28](https://github.com/user-attachments/assets/2ac5dc70-a6d4-475f-87fb-c99f152fb2ea)

```python
# 파이차트, 도넛차트 시각화를 위한 데이터 전처리

df2 = df[['country','height_cm']]
# 키 175 이상만 추출
df2=df2[df.height_cm >= 175]
df2 = df2.groupby('country').count().reset_index()

df2.head(10)
```
​
`df2=df2[df.height_cm >= 175]`
: 키 175 이상만 추출

<br>

```python
# 파이차트 시각화

fig = plt.figure(figsize=(8,8)) ## 캔버스 생성
fig.set_facecolor('white') ## 캔버스 배경색 설정
ax = fig.add_subplot() # 프레임 생성

# 파이차트 출력
ax.pie(df2.height_cm, 
       labels=df2.country, # 라벨 출력
       startangle=0, # 시작점 degree 설정
       counterclock=False, # 시계 방향
       autopct=lambda p : '{:.1f}%'.format(p) # 퍼센자릿수 설정
       )

plt.legend() # 범례 표시
plt.show()
```

​
`ax.pie(df2.height_cm, labels=df2.country, startangle=0, counterclock=False, autopct=lambda p : '{:.1f}%'.format(p))`
- ax.pie : 파이 차트 생성
- startangle=0 : 시작점 degree가 0
- counterclock=False : 시계 반대 방향
- autopct=lambda p : '{:.1f}%'.format(p) : 각 조각의 비율을 소수점 첫째 자리까지 표시하는 람다 함수

<br>

```python
# 도넛차트 시각화

# 차트 형태 옵션 설정
wedgeprops={'width': 0.7, 'edgecolor': 'w', 'linewidth': 5}

plt.pie(df2.height_cm, labels=df2.country, autopct='%.1f%%', 
        startangle=90, counterclock=False, wedgeprops=wedgeprops)
plt.show()
```

`wedgeprops={'width': 0.7, 'edgecolor': 'w', 'linewidth': 5}`
: 쐐기(wedge)의 속성을 설정, 너비를 0.7, 외곽선을 흰색(white), 외곽선의 두께 5

`plt.pie(df2.height_cm, labels=df2.country, autopct='%.1f%%', startangle=90, counterclock=False, wedgeprops=wedgeprops)`
- plt.pie() : 파이 차트 생성

<br>

```python
# 트리맵 차트 시각화

fig = px.treemap(df3,
                 path=['sex','country'],
                 values='height_cm',
                 color='height_cm',
                 color_continuous_scale='viridis')

fig.show()
```

`px.treemap(df3, path=['sex','country'], values='height_cm', color='height_cm', color_continuous_scale='viridis')`
- px.treemap() : 트리맵 생성
- path=['sex','country'] : 계층적 경로를 설정, 최상위 계층은 sex, 그 다음 계층은 country
-values='height_cm': 각 직사각형의 크기를 결정하는 값
-color='height_cm': 각 직사각형의 색상을 결정하는 값
-color_continuous_scale='viridis': 색상 스케일을 viridis로 설정

<br>

```python
# 와플차트 시각화

fig = plt.figure(
    FigureClass=Waffle,
    plots={
        111: {
            'values': df2['height_cm'],
            'labels': ["{0} ({1})".format(n, v) for n, v in df2['country'].items()],
            'legend': {'loc': 'upper left', 'bbox_to_anchor': (1.05, 1), 'fontsize': 8},
            'title': {'label': 'Waffle chart test', 'loc': 'left'}
        }
    },
    rows=10,
    figsize=(10, 10) 
)
```

`plots={111: {'values': df2['height_cm'],'labels': ["{0} ({1})".format(n, v) for n, v in df2['country'].items()], 'legend': {'loc': 'upper left', 'bbox_to_anchor': (1.05, 1), 'fontsize': 8},'title': {'label': 'Waffle chart test', 'loc': 'left'}`
- 111 : 서브플롯의 위치를 나타내며, 단일 서브플롯을 생성
- ‘values': df2['height_cm'] : 와플 차트의 각 블록의 크기를 나타내는 값
- 'labels': ["{0} ({1})".format(n, v) for n, v in df2['country'].items()] : 각 블록에 표시될 레이블을 설정
- 'bbox_to_anchor': (1.05, 1) : 범례를 플롯의 특정 위치로 이동시키는 데 사용, 1이 플롯의 끝을 말함

<br>

# 10.6 관계 시각화

## 산점도(scatter plot)

- 점들의 분포와 추세를 통해 두 변수 간의 관계 파악
- 극단치를 제거하는 것이 좋음 ← 극단치로 인해 주요 분포 구간이 압축되어 시각화의 효율이 떨어져서
- 데이터가 너무 많아서 점들이 겹쳐 정보를 제대로 확인할 수 x → 투명도를 주어 점들의 밀도 표현 or 빈도에 따른 농도나 색상을 다르게 표현
- 버블 차트
: 세 가지 요소의 상관관계 표현 가능 ← 버블의 크기를 통해 한가지 요소를 추가 가능
( 버블에 색상이나 농도 요소를 추가하여 네 가지 요소도 표현 가능 but 차트 해석이 어려워짐)
    - 원의 면적도 관찰해야하므로 관측치가 너무 많은 경우 정보 전달의 효율이 떨어짐
    - 관측치 > 100개 → 데이터 축약 or 다른 시각화 방법 사용
    - 해석 시, 원의 지름이 아닌 면적을 통해 크기 판단

## 관계 시각화 실습

```python
# 필요한 패키지 설치

import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import numpy as np
plt.rcParams['figure.dpi'] = 300
```

```python
# 데이터 불러오기
# https://www.kaggle.com/datasets/karthickveerakumar/startup-logistic-regression
df = pd.read_csv("datasets/50_Startups.csv")

# 데이터 샘플 확인
df.head()
```

```python
# 기본 산점도 시각화

plt.scatter(df['R&D Spend'], df['Profit'], s = 50, alpha = 0.4)
plt.show()
```

`plt.scatter(df['R&D Spend'], df['Profit'], s = 50, alpha = 0.4)`
- plt.scatter : 산점도 생성
- x축 : df['R&D Spend'], y축 : df['Profit']
- s = 50 : 점의 크기 50
![image-29](https://github.com/user-attachments/assets/c75210c3-efdb-4f60-80c7-e6b572d5cf78)

<br>

```python
# 산점도에 회귀선 추가
ax = sns.lmplot(x='R&D Spend', y='Profit', data= df)
```
​
`sns.lmplot(x='R&D Spend', y='Profit', data= df)` <br>
: Seaborn 라이브러리를 사용하여 산점도에 선형 회귀선을 추가
![image-30](https://github.com/user-attachments/assets/f00fdfda-696b-442d-a31e-96c117ab305c)

<br>

```python
# 네 가지 요소의 정보를 포함한 산점도 시각화

plt.scatter(df['R&D Spend'], df['Profit'], s=df['Marketing Spend']*0.001, 
            c=df['Administration'], alpha=0.5, cmap='Spectral')
plt.colorbar()
plt.show()
```

`s=df['Marketing Spend']*0.001` <br>
: 점의 크기를 Marketing Spend*0.001로 설정

`c=df['Administration']` <br>
: 점의 색상을 Administration으로 설정

`cmap='Spectral'` <br>
: 색상 맵을 'Spectral'
![image-31](https://github.com/user-attachments/assets/6ebb88a8-764c-4947-b32e-8106ad212968)

<br>

# 10.7 공간 시각화

: 위치 정보인 위도와 경도 데이터를 지도에 매핑하여 시각적으로 표현

- 일반적인 시각화 방법처럼 단순 이미지로 표현되는 것이 아닌, 지도를 확대하거나 위치를 옮기는 인터랙티브한 활용 가능
- 거시적 → 미시적, 스토리라인을 잡고 시각화 적용하는 것이 좋음

- 도트맵
    
    : 지리적 위치에 동일한 크기의 작은 점을 찍어서 해당 지역의 데이터 분포나 패턴을 표현하는 기법
    
    - 장점 : 시각적으로 데이터의 개요를 파악 쉬움
    단점 : 정확한 값 전달 x → 축소 시 수치 표현하고, 확대 시 점으로 표시하는 기법 사용
- 버블맵
    
    : 버블 차트를 지도에 옮긴 것
    
    - 장점: 데이터의 값이 원의 크기로 표현 → 코로플레스맵보다 비율을 비교한 데 효과적
    단점: 지나치게 큰 버블은 다른 버블과 겹칠 수 있음
- 코로플레스맵
    
    : 단계 구분도, 데이터 값의 크기에 따라 색상의 음영을 달리하여 해당 지역에 대한 값을 시각화하는 기법
    
    - 장점 : 여러 색상 혼합 가능, 투명도, 명도, 채도 등 다양하게 표현 가능
    단점 : 정확한 수치를 인지하고 비교하는 것 어려움
    - 큰 지역이 작은 지역들에 비해 강조되는 인상을 줄 수 있음 유의해야 함
- 커넥션맵, 링크맵
    
    : 지도에 찍힌 점들을 곡선 또는 직선으로 연결하여 지리적 관계 표현, 연속적 연결을 통해 지도에 경로 표현 가능
    
    - 연결선의 분포나 집중도를 통해 지리적 관계의 패턴을 파악하기 위해 사용
- 플로우맵
    
    : 커넥션맵과 유사하게 선을 표현하지만 시작점과 도착점이 함께 표현
    
- 카토그램
    
    : 각 지역의 면적을 데이터 값에 비례하도록 변형시켜 시각화
    ![image-32](https://github.com/user-attachments/assets/4aa4f67c-2968-41eb-a6d1-2d82b9b6438d)

## 공간 시각화 실습

```python
# 필요한 패키지 설치
!pip install folium
import folium
from folium import Marker
from folium import plugins
from folium import GeoJson
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import plotly.graph_objects as go

plt.rcParams['figure.dpi'] = 300
```

`!pip install folium` <br>
: Folium 라이브러리를 설치하는 명령
-  Folium은 Leaflet.js를 기반으로 하는 파이썬용 지도 시각화 라이브러리

`import folium` <br>
: Folium 라이브러리를 가져옴

`from folium import Marker` <br>
`from folium import plugins` <br>
`from folium import GeoJson` <br>
: Folium 라이브러리에서 Marker, plugins, GeoJson 모듈 가져옴

`import plotly.graph_objects as go` <br>
: Plotly 라이브러리의 graph_objects 모듈을 go라는 이름으로 가져옴

<br>

```python
# 서울 스타벅스 지점 데이터 불러오기
# https://www.kaggle.com/datasets/sewonghwang/starbucks-seoul
df=pd.read_csv("datasets/Starbucks_Seoul.csv")

# 지역 구분을 위한 json 파일 불러오기
geo="datasets/Seoul_Gu.json, encoding=cpg949" 

# 데이터 샘플 확인
df.head()
```

```python
# 기본 지도 시각화 (서울의 위도, 경도 입력)

m = folium.Map(location=[37.541, 126.986], zoom_start=12)
m
```

`folium.Map(location=[37.541, 126.986], zoom_start=12)`
: Folium을 사용하여 서울의 위도와 경도(37.541, 126.986)를 중심으로 기본 지도를 시각화, 초기 줌 레벨을 12로 설정

<br>

```python
# 지도 형태 변경
m = folium.Map(location=[37.541, 126.986], tiles='Stamen Toner', zoom_start=12)

# 원하는 좌표에 반경(radius) 표시 (남산)
folium.CircleMarker([37.5538, 126.9810],radius=50, 
                    popup='Laurelhurst Park', color='#3246cc', 
                    fill_color='#3246cc').add_to(m)

# 원하는 좌표에 포인트 표시 (남산)
folium.Marker([37.5538, 126.9810], popup='The Waterfront').add_to(m)
    
m
```

`tiles='Stamen Toner'` <br>
: 지도의 스타일을 'Stamen Toner'로 설정

`folium.CircleMarker([37.5538, 126.9810], radius=50, popup='Laurelhurst Park', color='#3246cc', fill_color='#3246cc').add_to(m)`
- folium.CircleMarker : 반경 표시
- [37.5538, 126.9810] : 위도와 경도
- radius=50 : 반경의 크기를 50으로 설정
- popup='Laurelhurst Park' : 반경을 클릭했을 때 나타날 팝업 메시지를 설정
- color='#3246cc’ : 반경의 테두리 색상을 설정
- fill_color='#3246cc' : 반경의 채우기 색상을 설정
- .add_to(m) : 객체를 지도에 추가

`folium.Marker([37.5538, 126.9810], popup='The Waterfront').add_to(m)`
- folium.Marker : 포인트 표시

<br>

```python
# 서울 지도에 스타벅스 지점 수 시각화

m = folium.Map([37.541, 126.986], zoom_start=12 ,width="%100", height="%100")
locations = list(zip(df.latitude, df.longitude))
cluster = plugins.MarkerCluster(locations=locations,                     
               popups=df["name"].tolist())  
m.add_child(cluster)
m
```

`width="%100", height="%100` <br>
: 지도의 너비와 높이를 각각 100%로 설정

`list(zip(df.latitude, df.longitude))` <br>
: df의 latitude 열과 longitude 열의 값들을 병렬로 결합하여 (위도, 경도) 튜플을 생성한 후, 리스트로 변환

`plugins.MarkerCluster(locations=locations, popups=df["name"].tolist())` <br>
: Folium 라이브러리의 MarkerCluster 플러그인을 사용하여 지도에 마커 클러스터를 추가
- 각 스타벅스 지점의 이름으로 구성되어 있는 리스트

`m.add_child(cluster)` <br>
: m(Folium 지도 객체)에 cluster(MarkerCluster 객체)를 추가

<br>

```python
# 서울 지도에 스타벅스 지점수 도드맵 시각화

m = folium.Map(location=[37.541, 126.986], zoom_start=12, width="%100", height="%100")
locations = list(zip(df.latitude, df.longitude))
for i in range(len(locations)):
    folium.CircleMarker(location=locations[i],radius=1).add_to(m)
m
```

`for i in range(len(locations)):`
`folium.CircleMarker(location=locations[i],radius=1).add_to(m)`
- folium.CircleMarker : 지도에 원형 마커를 추가

<br>

```python
# 서울 구 별 스타벅스 지점 수 집계 및 중심점 산출
df_m = df.groupby('gu_name').agg({'latitude':'mean',
                                  'longitude':'mean',
                                  'name':'count'}).reset_index()
df_m.head()
```

`.agg({'latitude':'mean', 'longitude':'mean', 'name':'count'})` <br>
- .agg :  pandas의 DataFrame과 Series에서 사용할 수 있는 집계(aggregation) 메서드, 평균(mean), 합계(sum), 최대값(max), 최소값(min) 등을 계산 가능

<br>

```python
# 서울 구 별 스타벅스 지점 수 버블맵 시각화

# 기본 지도 생성
m = folium.Map(location=[37.541, 126.986], tiles='Cartodb Positron', 
               zoom_start=11, width="%100", 
               height="%100")

# 구별 구분선, 색상 설정
folium.Choropleth(
    geo_data=geo, # 앞에서 불러온 json 파일 적용
    fill_color="gray"
    ).add_to(m)

# 버블맵 삽입
locations = list(zip(df_m.latitude, df_m.longitude))
for i in range(len(locations)):
    row = df_m.iloc[i]
    folium.CircleMarker(location=locations[i],
                        radius= float(row.name/2), # 버블 크기 설정
                        fill_color="blue"
                       ).add_to(m)
m

# radius에 카운팅을 넣어줌
# 만약 원이 커서 겹치면 float(row.name/1)의 분모값을 조정
```

`folium.Choropleth(geo_data=geo, fill_color="gray").add_to(m)` <br>
: Choropleth 지도를 생성하는 데 사용, 지리적 구역을 색으로 구분하여 시각적으로 표현, fill_color="gray"로 설정하여 경계의 색을 회색으로 설정

`for i in range(len(locations))` <br>
: locations 리스트의 길이만큼 루프를 돌면서 각 위치에 대해 마커를 생성 <br>
`row = df_m.iloc[i]` <br>
: df_m 데이터프레임의 i번째 행을 가져옴 <br>
`folium.CircleMarker(location=locations[i]…)` <br>
: locations[i] 위치에 원형 마커를 생성<br>
`radius= float(row.name/2)` <br>
: 마커의 반지름을 해당 구의 스타벅스 지점 수에 비례하도록 설정

<br>

```python
# 미국 실업률 정보의 코로플레스맵 시각화를 위한 데이터, json 불러오기
# https://www.kaggle.com/datasets/sewonghwang/us-unemployment
df2 =pd.read_csv("datasets/us_states_unemployment.csv")

# 주 별 경계 json 파일 불러오기
us_geo = 'datasets/folium_us-states.json'

df2.head()

```

```python
# 미국 주별 실업률 코로플레스맵 시각화

# 미국 지도 시각화
m = folium.Map(location=[40,-98], zoom_start=3, tiles="Cartodb Positron")

# 지도에 주 경계선, 실업률 데이터 연동
m.choropleth(geo_data = us_geo, # json 데이터
               data = df2, # 실업률 데이터
               columns = ['State','Unemployment'], # 연동할 컬럼 설정
               key_on = 'feature.id', # json과 실업률 데이터를 연결할 키값 설정
               fill_color='YlGn',
               legend_name='실업률')

m
```

`columns = ['State','Unemployment']` <br>
: df2에서 연동할 칼럼 지정

`key_on = 'feature.id'` <br>
: json파일과 df를 연결하는 키를 id로 설정

<br>

```python
# 서울과 각국의 수도 간의 커넥션맵 시각화

# 서울과 도쿄, 워싱턴, 마닐라, 파리, 모스크바 위경도 입력
source_to_dest = zip([37.541,37.541,37.541,37.541,37.541], #서울 위도
                     [35.6804, 38.9072, 14.5995, 48.8566,55.7558], #나머지 위도
                     [126.986,126.986,126.986,126.986,126.986], #서울 경도
                     [139.7690, -77.0369, 120.9842, 2.3522,37.6173]) #나머지 경도

fig = go.Figure()

## for 문을 활용하여 위경도 입력
for a, b, c, d in source_to_dest:
    fig.add_trace(go.Scattergeo(
                        lat = [a, b],
                        lon = [c, d],
                        mode = 'lines',
                        line = dict(width = 1, color="red"),
                        opacity = 0.5 # 선 투명도
                        ))

fig.update_layout(
                margin={"t":0,"b":0,"l":0, "r":0, "pad":0},
                showlegend=False,
                geo = dict(
                showcountries=True) # 국가 경계선
                )

fig.show()
```

`fig = go.Figure()` <br>
: 빈 Figure 객체를 생성, 시각화를 위한 기본 구조를 제공하지만 초기에는 아무런 데이터나 시각적 요소가 포함되지 않은 상태

`fig.add_trace(go.Scattergeo(lat = [a, b], lon = [c, d], mode = 'lines', line = dict(width = 1, color="red"), opacity = 0.5))`
- .add_trace(go.Scattergeo()) : 각 도시와 서울을 연결하는 경로를 `Figure` 객체에 추가하는 메서드

`fig.update_layout(margin={"t":0,"b":0,"l":0, "r":0, "pad":0}, showlegend=False, geo = dict(showcountries=True))`
- .update_layout : Plotly 시각화의 레이아웃을 업데이트하는 메서드
- showlegend=False : 범례 숨김
- geo = dict(showcountries=True : 국가 경계선을 표시함)

<br>

# 10.8 박스 플롯

: 네모 상장 모양에 최댓값과 최솟값을 나타내는 선이 결합된 모양의 데이터 시각화 방법

- 두 변수의 값을 비교할 때 효과적
![image-33](https://github.com/user-attachments/assets/0f9c3c11-ef41-4a60-b143-91f3a04fad49)

## 박스 플롯 실습

```python
# 필요한 패키지 설치

import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
plt.rcParams['figure.dpi'] = 300
```

```python
# 데이터 불러오기
# https://www.kaggle.com/datasets/karthickveerakumar/startup-logistic-regression
df = pd.read_csv("datasets/50_Startups.csv")

# 데이터 샘플 확인
df.head()
```

```python
# Profit 변수로 기본 가로 세로 박스 플롯 시각화

# 세로 박스 플롯
plt.figure(figsize = (8, 6))
sns.boxplot(y = 'Profit', data = df)
plt.show()

# 가로 박스 플롯
plt.figure(figsize = (8, 2))
sns.boxplot(x = 'Profit', data = df)
plt.show()
```
![image-34](https://github.com/user-attachments/assets/35aef1a6-33cb-4d3f-a944-7e3cfd693ecf)
![image-35](https://github.com/user-attachments/assets/59eca9f8-1b66-4671-94f0-56b90d9c8035)
```python
# State 구분에 따른 Profit 박스 플롯 시각화

plt.figure(figsize=(8,5))
sns.boxplot(x="State", y="Profit", data=df)
plt.show()
```
![image-36](https://github.com/user-attachments/assets/c514192b-5b14-4cbf-93c6-a6a2da37dd8d)

```python
# 평균, 데이터 포인트 포함한 박스 플롯 시각화
sns.boxplot(x="State", y="Profit", 
            showmeans=True, 
            boxprops={'facecolor':'None'}, 
            data=df)

sns.stripplot(x='State', y='Profit', 
              data=df, 
              jitter=True, 
              marker='o', 
              alpha=0.5,
              color='black')

plt.show()
```
![image-37](https://github.com/user-attachments/assets/f0f548b6-1ea4-4c1e-899c-fa37d233bbdc)
`jitter=True`
: 데이터 포인트를 약간 무작위로 분산시켜 포인트들이 겹치지 않도록 

`marker='o'`
: 데이터 포인트를 원형(marker 'o')으로 표시
